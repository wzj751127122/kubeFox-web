var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, ref, onMounted, markRaw, watch, unref, openBlock, createElementBlock, computed, nextTick, shallowRef, getCurrentInstance, onBeforeUnmount, normalizeClass, normalizeStyle, createBlock, resolveDynamicComponent, mergeProps } from "vue";
import "codemirror/lib/codemirror.css";
import _CodeMirror from "codemirror";
import "codemirror/addon/merge/merge.css";
import "codemirror/addon/merge/merge.js";
import DiffMatchPatch from "diff-match-patch";
import "codemirror/addon/mode/simple.js";
!window.CodeMirror && (window.CodeMirror = _CodeMirror);
const CodeMirror$1 = window.CodeMirror || _CodeMirror;
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$3 = defineComponent({
  name: "DefaultMode",
  props: {
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    value: {
      type: String,
      default: ""
    },
    content: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => null
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: {
    ready: (instance) => instance,
    "update:cminstance": (instance) => instance
  },
  setup(props, { emit }) {
    const textarea = ref();
    const _cminstance = ref(null);
    const initialize = () => {
      _cminstance.value = markRaw(CodeMirror$1.fromTextArea(textarea.value, props.options));
      emit("update:cminstance", _cminstance.value);
      const unwatch = watch(() => props.cminstance, (val) => {
        var _a;
        val && ((_a = props.cminstance) == null ? void 0 : _a.setValue(props.value || props.content));
        emit("ready", unref(_cminstance));
        unwatch == null ? void 0 : unwatch();
      }, { deep: true });
    };
    onMounted(() => {
      initialize();
    });
    return {
      textarea,
      initialize
    };
  }
});
const _hoisted_1$2 = ["name", "placeholder"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    ref: "textarea",
    name: _ctx.$props.name,
    placeholder: _ctx.$props.placeholder
  }, null, 8, _hoisted_1$2);
}
var Default = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2]]);
window.diff_match_patch = DiffMatchPatch;
window.DIFF_DELETE = -1;
window.DIFF_INSERT = 1;
window.DIFF_EQUAL = 0;
const _sfc_main$2 = defineComponent({
  name: "MergeMode",
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(props, { emit }) {
    const _cminstance = ref();
    const mergeView = ref();
    const initialize = () => {
      _cminstance.value = markRaw(CodeMirror$1.MergeView(mergeView.value, props.options));
      emit("update:cminstance", _cminstance.value);
      emit("ready", _cminstance);
    };
    onMounted(() => {
      initialize();
    });
    return {
      mergeView,
      initialize
    };
  }
});
const _hoisted_1$1 = { ref: "mergeView" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, null, 512);
}
var Merge = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1]]);
var logErrorType;
(function(logErrorType2) {
  logErrorType2["info"] = "info";
  logErrorType2["warning"] = "warning";
  logErrorType2["error"] = "error";
})(logErrorType || (logErrorType = {}));
function getLocalTime() {
  const date = new Date();
  const h = date.getHours() < 10 ? `0${date.getHours()}` : date.getHours();
  const m = date.getMinutes() < 10 ? `0${date.getMinutes()}` : date.getMinutes();
  const s = date.getSeconds() < 10 ? `0${date.getSeconds()}` : date.getSeconds();
  return `${h}:${m}:${s}`;
}
function createLinkMark(attrs) {
  return `#link#${JSON.stringify(attrs)}#link#`;
}
function getLinkMarks(value) {
  const linkRegexp = /#link#(.+)#link#/g;
  const result = [];
  let indexObj;
  indexObj = linkRegexp.exec(value);
  while (indexObj) {
    const node = document.createElement("a");
    const attrs = JSON.parse(indexObj[1]);
    const keyAndValues = Object.entries(attrs);
    for (const [_key, _value] of keyAndValues) {
      node.setAttribute(_key, _value);
    }
    node.className = "editor_custom_link";
    node.innerHTML = "logDownload";
    result.push({
      start: indexObj.index,
      end: indexObj.index + indexObj[0].length,
      node
    });
    indexObj = linkRegexp.exec(value);
  }
  return result;
}
function createLogMark(text = "", type = "info") {
  return `#log<${type}>log#${text}#log<${type}>log#`;
}
function getLogMark(value) {
  const result = [];
  function match() {
    const logRegexp = /#log<(\w*)>log#((.|\r\n|\n)*?)#log<(\w*)>log#/g;
    let indexObj;
    indexObj = logRegexp.exec(value);
    while (indexObj) {
      const text = indexObj[0].replace(/\r\n/g, "\n");
      const textArr = text.split("\n");
      const content = indexObj[2].replace(/\r\n/g, "\n");
      const contentArr = content.split("\n");
      const node = document.createElement("span");
      const type = indexObj[1];
      node.className = `c-editor--log__${type}`;
      let offset = 0;
      for (let i = 0; i < textArr.length; i++) {
        const textItem = textArr[i];
        const contentItem = contentArr[i];
        const cloneNode = node.cloneNode(false);
        cloneNode.innerText = contentItem;
        result.push({
          start: indexObj.index + offset,
          end: indexObj.index + offset + textItem.length,
          node: cloneNode
        });
        offset = offset + textItem.length + 1;
      }
      indexObj = logRegexp.exec(value);
    }
  }
  match();
  return result;
}
function createLog(log, type) {
  const now = getLocalTime();
  return `[${now}] <${type}> ${log}`;
}
function createTitle(title, symbolLength, symbol) {
  const arr = new Array(Math.max(symbolLength || 15, 5));
  const wrapText = arr.join(symbol || "=");
  return `${wrapText}${title}${wrapText}`;
}
const startRegex = [
  {
    regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/,
    token: ["tag", "", "error.strong", "error.strong"],
    sol: true
  },
  {
    regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/,
    token: ["tag", "", "bracket", "bracket", "hr"],
    sol: true
  },
  {
    regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/,
    token: ["tag", "", "comment", "comment", "hr"],
    sol: true
  }
];
CodeMirror$1.defineSimpleMode("fclog", {
  start: [
    ...startRegex,
    {
      regex: /.*/,
      token: "hr"
    }
  ],
  error: [
    ...startRegex,
    {
      regex: /.*/,
      token: "error.strong"
    }
  ],
  info: [
    ...startRegex,
    {
      regex: /.*/,
      token: "bracket"
    }
  ],
  warning: [
    ...startRegex,
    {
      regex: /.*\[/,
      token: "comment"
    }
  ]
});
CodeMirror$1.defineSimpleMode("log", {
  start: [
    {
      regex: /^[=]+[^=]*[=]+/,
      token: "strong"
    },
    {
      regex: /([^\w])([A-Z][\w]*)/,
      token: ["", "string"]
    },
    {
      regex: /(^[A-Z][\w]*)/,
      token: "string"
    }
  ]
});
const _sfc_main$1 = defineComponent({
  name: "CodemirrorFclog",
  props: {
    value: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(props, { emit }) {
    const textarea = ref();
    const _cminstance = ref(null);
    const renderTextMark = (cminstance = props.cminstance) => {
      const marks = cminstance.getAllMarks();
      marks.forEach((mark) => mark.clear());
      const value = cminstance.getValue();
      const linkMarks = [].concat(getLinkMarks(value)).concat(getLogMark(value));
      for (let _i = 0; _i < linkMarks.length; _i++) {
        const mark = linkMarks[_i];
        cminstance.markText(cminstance.posFromIndex(mark.start), cminstance.posFromIndex(mark.end), { replacedWith: mark.node });
      }
    };
    const initialize = () => {
      var _a;
      _cminstance.value = markRaw(CodeMirror$1.fromTextArea(textarea.value, props.options));
      emit("update:cminstance", unref(_cminstance));
      (_a = _cminstance.value) == null ? void 0 : _a.on("change", renderTextMark);
    };
    watch(() => props.cminstance, (val) => {
      var _a;
      if (val) {
        renderTextMark(props.cminstance);
        (_a = props.cminstance) == null ? void 0 : _a.setValue(props.value);
        emit("ready", _cminstance);
      }
    }, { deep: true, immediate: true });
    onMounted(() => {
      initialize();
    });
    return {
      initialize,
      textarea
    };
  }
});
const _hoisted_1 = ["name", "placeholder"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    ref: "textarea",
    name: _ctx.$props.name,
    placeholder: _ctx.$props.placeholder
  }, null, 8, _hoisted_1);
}
var FcLog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render]]);
const componentEventMap = {
  "update:value": (value) => value,
  change: (value, cm) => ({ value, cm }),
  input: (value) => value,
  ready: (cm) => cm
};
const cmEvts = [
  "changes",
  "scroll",
  "beforeChange",
  "cursorActivity",
  "keyHandled",
  "inputRead",
  "electricInput",
  "beforeSelectionChange",
  "viewportChange",
  "swapDoc",
  "gutterClick",
  "gutterContextMenu",
  "focus",
  "blur",
  "refresh",
  "optionChange",
  "scrollCursorIntoView",
  "update"
];
const getCmEvts = () => {
  const result = {};
  cmEvts.forEach((name) => {
    result[name] = (...args) => args;
  });
  return result;
};
const emitOptions = __spreadValues(__spreadValues({}, componentEventMap), getCmEvts());
const DEFAULT_OPTIONS = {
  mode: "text",
  theme: "default",
  lineNumbers: true,
  smartIndent: true,
  indentUnit: 2
};
function scrollToEnd(cm) {
  Promise.resolve().then(() => {
    const nowScrollInfo = cm.getScrollInfo();
    cm.scrollTo(nowScrollInfo.left, nowScrollInfo.height);
  });
}
const useEvents = ({
  props,
  cminstance,
  emit,
  internalInstance,
  content
}) => {
  const realCm = computed(() => {
    var _a;
    return props.merge ? (_a = unref(cminstance)) == null ? void 0 : _a.editor() : unref(cminstance);
  });
  const getBindEvents = () => {
    const evts = [];
    Object.keys(internalInstance == null ? void 0 : internalInstance.vnode.props).forEach((v) => {
      if (v.startsWith("on")) {
        const e = v.replace(v[2], v[2].toLowerCase()).slice(2);
        !componentEventMap[e] && evts.push(e);
      }
    });
    return evts;
  };
  const listenerEvents = () => {
    realCm.value.on("change", (cm) => {
      const currentVal = cm.getValue();
      if (currentVal === content.value)
        return;
      content.value = currentVal;
      content.value && emit("update:value", content.value || "");
      content.value && emit("input", content.value || "");
      Promise.resolve().then(() => {
        emit("change", content.value, cm);
      });
      props.keepCursorInEnd && scrollToEnd(cm);
    });
    const tmpEvents = {};
    const bindEvts = getBindEvents();
    bindEvts.filter((e) => !tmpEvents[e] && (tmpEvents[e] = true)).forEach((event) => {
      realCm.value.on(event, (...args) => {
        emit(event, ...args);
      });
    });
  };
  return {
    listenerEvents
  };
};
function useViewControl({
  props,
  cminstance,
  presetRef
}) {
  const containerWidth = ref(null);
  const containerHeight = ref(null);
  const realCm = computed(() => {
    var _a;
    return props.merge ? (_a = unref(cminstance)) == null ? void 0 : _a.editor() : unref(cminstance);
  });
  const refresh = () => {
    nextTick(() => {
      var _a;
      (_a = realCm.value) == null ? void 0 : _a.refresh();
    });
  };
  const resize = (width = props.width, height = props.height) => {
    var _a;
    containerWidth.value = String(width).replace("px", "");
    containerHeight.value = String(height).replace("px", "");
    const cmHeight = containerHeight.value;
    (_a = realCm.value) == null ? void 0 : _a.setSize(containerWidth.value, cmHeight);
  };
  const destroy = () => {
    var _a;
    const element = (_a = realCm.value) == null ? void 0 : _a.getWrapperElement();
    element == null ? void 0 : element.remove();
  };
  const reload = () => {
    var _a, _b, _c;
    const history = (_a = realCm.value) == null ? void 0 : _a.getDoc().getHistory();
    (_b = presetRef.value) == null ? void 0 : _b.initialize();
    destroy();
    (_c = realCm.value) == null ? void 0 : _c.getDoc().setHistory(history);
  };
  const isStyleChaotic = () => {
    const gutterEl = document.querySelector(".CodeMirror-gutters");
    const gutterElLeft = gutterEl == null ? void 0 : gutterEl.style.left.replace("px", "");
    return gutterElLeft !== "0";
  };
  const reviseStyle = () => {
    refresh();
    if (!isStyleChaotic())
      return;
    const timer = setInterval(() => {
      isStyleChaotic() ? refresh() : clearInterval(timer);
    }, 60);
    const clearTimer = setTimeout(() => {
      clearInterval(timer);
      clearTimeout(clearTimer);
    }, 400);
  };
  return {
    reload,
    refresh,
    resize,
    destroy,
    containerHeight,
    reviseStyle
  };
}
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    value: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => DEFAULT_OPTIONS
    },
    globalOptions: {
      type: Object,
      default: () => DEFAULT_OPTIONS
    },
    placeholder: {
      type: String,
      default: ""
    },
    border: {
      type: Boolean,
      default: false
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: null
    },
    originalStyle: {
      type: Boolean,
      default: false
    },
    keepCursorInEnd: {
      type: Boolean,
      default: false
    },
    merge: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: ""
    },
    marker: {
      type: Function,
      default: () => null
    },
    unseenLines: {
      type: Array,
      default: () => []
    }
  },
  emits: emitOptions,
  setup(__props, { expose, emit }) {
    var _a, _b;
    const props = __props;
    if (typeof Object.assign !== "function") {
      Object.defineProperty(Object, "assign", {
        value(target, varArgs) {
          if (target == null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          const to = Object(target);
          for (let index2 = 1; index2 < arguments.length; index2++) {
            const nextSource = arguments[index2];
            if (nextSource != null) {
              for (const nextKey in nextSource) {
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
          return to;
        },
        writable: true,
        configurable: true
      });
    }
    const cminstance = ref(null);
    const content = ref("");
    const presetModeName = shallowRef(Default);
    const cmOptions = ref(__spreadValues(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS), props.globalOptions), props.options));
    const internalInstance = getCurrentInstance();
    const instanceName = props.name || ((_b = (_a = internalInstance == null ? void 0 : internalInstance.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.name) || void 0;
    const presetRef = ref(null);
    const realCminstance = computed(() => {
      var _a2;
      return props.merge ? (_a2 = unref(cminstance)) == null ? void 0 : _a2.editor() : unref(cminstance);
    });
    const { refresh, resize, destroy, containerHeight, reviseStyle } = useViewControl({
      props,
      cminstance,
      presetRef
    });
    const { listenerEvents } = useEvents({
      props,
      cminstance,
      emit,
      internalInstance,
      content
    });
    const unseenLineMarkers = () => {
      if (props.unseenLines !== void 0 && props.marker !== void 0) {
        props.unseenLines.forEach((line) => {
          var _a2, _b2;
          const info = (_a2 = cminstance.value) == null ? void 0 : _a2.lineInfo(line);
          (_b2 = cminstance.value) == null ? void 0 : _b2.setGutterMarker(line, "breakpoints", (info == null ? void 0 : info.gutterMarkers) ? null : props.marker());
        });
      }
    };
    const onCodeChange = (newVal) => {
      var _a2, _b2;
      const CM_VALUE = (_a2 = cminstance.value) == null ? void 0 : _a2.getValue();
      if (newVal !== CM_VALUE) {
        (_b2 = cminstance.value) == null ? void 0 : _b2.setValue(newVal);
        content.value = newVal;
        reviseStyle();
      }
      unseenLineMarkers();
    };
    const ready = () => {
      listenerEvents();
      unseenLineMarkers();
      resize(props.width, props.height);
      emit("ready", cminstance.value);
      watch([() => props.width, () => props.height], ([width, height]) => {
        resize(width, height);
      }, { deep: true });
    };
    const handlePresetModeName = () => {
      if (props.options.mode === "fclog" || props.options.mode === "log") {
        presetModeName.value = FcLog;
        return;
      }
      if (props.merge) {
        presetModeName.value = Merge;
        return;
      }
      presetModeName.value = Default;
    };
    watch(() => props.options, (val) => {
      var _a2;
      for (const key in props.options) {
        (_a2 = realCminstance.value) == null ? void 0 : _a2.setOption(key, unref(val[key]));
      }
    }, { deep: true });
    watch(() => props.value, (val) => {
      onCodeChange(val);
    });
    watch(() => props.placeholder, (val) => {
      var _a2;
      (_a2 = realCminstance.value) == null ? void 0 : _a2.setOption("placeholder", val);
    });
    watch(() => props.merge, (val) => {
      handlePresetModeName();
    }, { immediate: true });
    onBeforeUnmount(() => {
      destroy();
    });
    expose({
      cminstance,
      resize,
      refresh,
      destroy
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["codemirror-container", {
          merge: _ctx.$props.merge,
          bordered: _ctx.$props.border || _ctx.$props.merge && !props.originalStyle,
          "width-auto": !_ctx.$props.width || _ctx.$props.width == "100%",
          "height-auto": !_ctx.$props.height || _ctx.$props.height == "100%",
          "original-style": props.originalStyle
        }]),
        style: normalizeStyle({
          height: unref(containerHeight) + "px"
        })
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(unref(presetModeName)), mergeProps({
          ref_key: "presetRef",
          ref: presetRef,
          cminstance: cminstance.value,
          "onUpdate:cminstance": _cache[0] || (_cache[0] = ($event) => cminstance.value = $event),
          style: { "height": "100%" }
        }, __spreadProps(__spreadValues(__spreadValues({}, _ctx.$props), _ctx.$attrs), {
          options: cmOptions.value,
          name: unref(instanceName),
          content: content.value
        }), { onReady: ready }), null, 16, ["cminstance"]))
      ], 6);
    };
  }
});
var index = "";
const install = (app, config) => {
  if (config) {
    if (config.options) {
      _sfc_main.props.globalOptions.default = () => config.options;
    }
  }
  app.component((config == null ? void 0 : config.componentName) || "Codemirror", _sfc_main);
  return app;
};
const CodeMirror = window.CodeMirror || CodeMirror$1;
const GlobalCmComponent = install;
function styleInject(css,ref){if(ref===void 0){ref={}}var insertAt=ref.insertAt;if(!css||typeof document==="undefined"){return}var head=document.head||document.getElementsByTagName("head")[0];var style=document.createElement("style");style.type="text/css";if(insertAt==="top"){if(head.firstChild){head.insertBefore(style,head.firstChild)}else{head.appendChild(style)}}else{head.appendChild(style)}if(style.styleSheet){style.styleSheet.cssText=css}else{style.appendChild(document.createTextNode(css))}};styleInject(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 12px;
  overflow: hidden;
}
.codemirror-container.bordered {
  border-radius: 4px;
  border: 1px solid #dddddd;
}
.codemirror-container.width-auto {
  width: 100%;
}
.codemirror-container.height-auto {
  height: 100%;
}
.codemirror-container.height-auto .CodeMirror,
.codemirror-container.height-auto .cm-s-default {
  height: 100% !important;
}
.codemirror-container .editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.codemirror-container .editor_custom_link:hover {
  color: #04b4fa;
}
.codemirror-container:not(.original-style) .CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.codemirror-container:not(.original-style) .CodeMirror,
.codemirror-container:not(.original-style) .CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.codemirror-container:not(.original-style) .CodeMirror-merge,
.codemirror-container:not(.original-style) .CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.codemirror-container:not(.original-style) .c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__warning {
  color: #ee9900;
}
.codemirror-container:not(.original-style) .c-editor--log__success {
  color: #669600;
}
.codemirror-container:not(.original-style) .cm-header,
.codemirror-container:not(.original-style) .cm-strong {
  font-weight: bold;
}
`);
export { CodeMirror, GlobalCmComponent, _sfc_main as VueCodemirror, createLinkMark, createLog, createLogMark, createTitle, _sfc_main as default, getLinkMarks, getLocalTime, getLogMark, logErrorType };
